いいね。①「型安全レシピ提案アプリ」を Go + Genkit Go 1.0 で一気に動かせる最小構成に落としました。前提は「ローカルで Gemini API を使って、構造化出力を Go の struct にマッピング →HTTP でも叩けるようにフローを公開 →Dev UI で可視化」です。

コンテキスト/前提と設計意図
• 前提: Go 1.24+、Genkit CLI、Gemini API Key（無料枠あり）を使用。モデルは gemini-2.5-flash を既定にします。 ￼
• 設計: Genkit の Flow に入出力スキーマ（Go struct）を紐づけ、GenerateData[T]で型安全な構造化出力を得る。HTTP エンドポイント(/recipeGeneratorFlow)公開＋ Dev UI(ポート 4000)で実行とトレース確認。 ￼

⸻

手順（コピペで OK）

1. セットアップ

# Genkit CLI

curl -sL cli.genkit.dev | bash

# Go プロジェクト

mkdir genkit-recipe && cd genkit-recipe
go mod init example/genkit-recipe

# Genkit Go ライブラリ

go get github.com/firebase/genkit/go

    •	CLIインストール、Goモジュール初期化、Go用Genkitパッケージ導入の流れです。 ￼

2. API キー設定（Gemini）

export GEMINI_API_KEY="あなたの API キー"

    •	Geminiキーの環境変数名は GEMINI_API_KEY。 ￼

3. main.go を作成

package main

import (
"context"
"encoding/json"
"fmt"
"log"
"net/http"

    "github.com/firebase/genkit/go/ai"
    "github.com/firebase/genkit/go/genkit"
    "github.com/firebase/genkit/go/plugins/googlegenai"
    "github.com/firebase/genkit/go/plugins/server"

)

// --- 入力と出力の型（=スキーマ） ---
type RecipeInput struct {
Ingredient string `json:"ingredient" jsonschema:"description=Main ingredient or cuisine type"`
DietaryRestrictions string `json:"dietaryRestrictions,omitempty" jsonschema:"description=Any dietary restrictions"`
}

type Recipe struct {
Title string `json:"title"`
Description string `json:"description"`
PrepTime string `json:"prepTime"`
CookTime string `json:"cookTime"`
Servings int `json:"servings"`
Ingredients []string `json:"ingredients"`
Instructions []string `json:"instructions"`
Tips []string `json:"tips,omitempty"`
}

func main() {
ctx := context.Background()

    // Genkit初期化: Google AIプラグイン＋既定モデルを設定
    g := genkit.Init(ctx,
    	genkit.WithPlugins(&googlegenai.GoogleAI{}),
    	genkit.WithDefaultModel("googleai/gemini-2.5-flash"),
    )

    // Flow定義：入力→構造化レシピを返す
    recipeGeneratorFlow := genkit.DefineFlow(g, "recipeGeneratorFlow", func(ctx context.Context, input *RecipeInput) (*Recipe, error) {
    	dr := input.DietaryRestrictions
    	if dr == "" {
    		dr = "none"
    	}
    	prompt := fmt.Sprintf(`Create a recipe with the following requirements:

Main ingredient: %s
Dietary restrictions: %s`, input.Ingredient, dr)

    	// 型T=Recipeの構造化出力を要求
    	recipe, _, err := genkit.GenerateData[Recipe](ctx, g, ai.WithPrompt(prompt))
    	if err != nil {
    		return nil, fmt.Errorf("failed to generate recipe: %w", err)
    	}
    	return recipe, nil
    })

    // まず1回だけローカル実行して結果を確認
    recipe, err := recipeGeneratorFlow.Run(ctx, &RecipeInput{
    	Ingredient:          "avocado",
    	DietaryRestrictions: "vegetarian",
    })
    if err != nil {
    	log.Fatalf("could not generate recipe: %v", err)
    }
    out, _ := json.MarshalIndent(recipe, "", "  ")
    fmt.Println("Sample recipe generated:")
    fmt.Println(string(out))

    // HTTP公開（Dev UI連携のため存続）
    mux := http.NewServeMux()
    mux.HandleFunc("POST /recipeGeneratorFlow", genkit.Handler(recipeGeneratorFlow))
    log.Println("Starting server on http://localhost:3400")
    log.Println("Flow available at: POST http://localhost:3400/recipeGeneratorFlow")
    log.Fatal(server.Start(ctx, "127.0.0.1:3400", mux))

}

    •	この構成は公式「Get started（Go）」のレシピ例と同等の流れ（Go structをスキーマに、GenerateData[T]で構造化出力、Flow公開）です。 ￼

4. 実行

go run .

    •	JSONのレシピが出力され、続いて http://localhost:3400 のサーバが起動します。 ￼

5. HTTP で叩く（別ターミナル）

curl -X POST "http://localhost:3400/recipeGeneratorFlow" \
 -H "Content-Type: application/json" \
 -d '{"data": {"ingredient": "tomato", "dietaryRestrictions": "vegan"}}'

    •	FlowはHTTP APIとして呼べます（本番でBFFやAPIゲートウェイ配下に置くイメージ）。 ￼

6. Dev UI で可視化（推奨）

genkit start -- go run .

# ブラウザ: http://localhost:4000 から Flow を選び、入力 JSON を与えて Run

    •	Dev UIで入出力・トレース・プロンプトを視覚確認できます（Flow運用時のDXが良い）。 ￼

⸻

進化させると良い点（任意）
• 温度や最大トークンをモデル設定として渡す（出力の安定度や長さを制御）。 ￼
• OpenAI 互換プラグインに差し替えて比較ベンチ（compat_oai で OpenAI や互換 API に接続）。 ￼
• ストリーミングやツール呼び出しに拡張（天気取得など外部 API 連携）—まずは上記の型安全フローで基礎を固めるとスムーズ。 ￼

⸻
